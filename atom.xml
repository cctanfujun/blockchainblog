<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓晨区块</title>
  
  <subtitle>区块链、以太坊、EOS 开发</subtitle>
  <link href="/blockchainblog/atom.xml" rel="self"/>
  
  <link href="http://tanfujun.com/"/>
  <updated>2018-09-17T09:34:24.552Z</updated>
  <id>http://tanfujun.com/</id>
  
  <author>
    <name>xiaochendev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>晓晨EOS开发教程1 -- 搭建开发环境(Docker)</title>
    <link href="http://tanfujun.com/2018/09/17/xiaochen-eos-development-tutorial-1-building-a-environment-docker/"/>
    <id>http://tanfujun.com/2018/09/17/xiaochen-eos-development-tutorial-1-building-a-environment-docker/</id>
    <published>2018-09-17T07:53:24.000Z</published>
    <updated>2018-09-17T09:34:24.552Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 17 2018 17:34:55 GMT+0800 (CST) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>接下来计划做一个 EOS 应用开发的教程,区块链上的应用开发和我们正常的App开发在开发模式上略有区别,传统的开发模式一般是前端人员开发App，服务端人员开发服务端暴露接口，前端和和服务端进行交互，而区块链应用的开发，一般是前端人员开发app,通过区块链sdk(web3.js、eosjs等)调用智能合约开发者开发的智能合约和区块链交互。如图:</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvco6hcgrmj31kw16odua.jpg" alt="架构图"></p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>eos 为了避免环境不一致以及各种依赖问题，提供了使用 docker 镜像方便我们使用。</p><p>首先需要安装 docker 各个系统的童鞋请自行下载安装。</p><p>eos docker 镜像地址: <a href="https://hub.docker.com/r/eosio/eos-dev/tags/" target="_blank" rel="noopener">https://hub.docker.com/r/eosio/eos-dev/tags/</a></p><p>eosio 的库下有几个镜像:</p><ul><li>eos 主网使用，不包含开发依赖</li><li>eos-dev 包含开发环境，供开发使用</li><li>builder 完整的编译环境</li><li>ci 暂不清楚</li></ul><p>我们要下载开发环境 eos-dev 执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull eosio/eos-dev:v1.2.5</span><br><span class="line"></span><br><span class="line">docker tag eosio/eos-dev:v1.2.5 eosio/eos-dev:latest</span><br></pre></td></tr></table></figure><p>下载完成镜像,我们接下来准备使用 docker-compose 来启动节点,说一下什么是 docker-compose ,假设我们要启动一个 web 服务,我们可能要启动多个service,甚至4个 service 的启动顺序和参数也要控制，如果我们都使用 <code>docker run</code> 就太不方便了，所以把多个服务的参数和关系描述到一个文件中，之后只要执行这个文件即可。docker-compose 在 mac 系统下是随着 docker 一起安装的，如果使用其他系统可能需要额外安装，请自行查询。</p><p>我们新建一个 eos 文件夹作为项目文件夹，新建 eos-local-compose.yml 文件,内容如下：</p><p><strong>eos-local-compose.yml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nodeosd:</span><br><span class="line">    image: eosio/eos-dev:latest</span><br><span class="line">    command: /opt/eosio/bin/nodeosd.sh --data-dir /opt/eosio/bin/data-dir -e --delete-all-blocks --http-validate-host=false #--genesis-json /opt/eosio/bin/data-dir/genesis.json #--contracts-console #-e — Enable block production, even if the chain is stale</span><br><span class="line">    hostname: nodeosd</span><br><span class="line">    ports:</span><br><span class="line">      - 8888:8888</span><br><span class="line">      - 9876:9876</span><br><span class="line">    expose:</span><br><span class="line">      - &quot;8888&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - local-nodeos-data-volume:/opt/eosio/bin/data-dir</span><br><span class="line">      #- ./config-local-v1.2.3.ini:/opt/eosio/bin/data-dir/config.ini</span><br><span class="line"></span><br><span class="line">  keosd:</span><br><span class="line">    image: eosio/eos-dev:latest</span><br><span class="line">    command: /opt/eosio/bin/keosd --wallet-dir /opt/eosio/bin/data-dir --http-server-address=127.0.0.1:8900 --http-validate-host=false</span><br><span class="line">    hostname: keosd</span><br><span class="line">    links:</span><br><span class="line">      - nodeosd</span><br><span class="line">    volumes:</span><br><span class="line">      - local-keosd-data-volume:/opt/eosio/bin/data-dir</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line"> local-nodeos-data-volume:</span><br><span class="line">   external: true</span><br><span class="line"> local-keosd-data-volume:</span><br><span class="line">   external: true</span><br></pre></td></tr></table></figure><p>然后创建2个volume供2个服务nodeos、keosd挂载使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker volume create --name=local-nodeos-data-volume</span><br><span class="line"></span><br><span class="line">docker volume create --name=local-keosd-data-volume</span><br></pre></td></tr></table></figure><p>接下来启动节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f eos-local-compose.yml up -d</span><br></pre></td></tr></table></figure><p>-f 指定文件名<br>up 启动容器<br>-d 放到后台</p><p>可以看到命令行提示创建服务成功。</p><p>执行查看nodeos的log,如果正在出块，表示测试节点启动成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f eos_nodeosd_1</span><br></pre></td></tr></table></figure><h2 id="配置别名方便使用"><a href="#配置别名方便使用" class="headerlink" title="配置别名方便使用"></a>配置别名方便使用</h2><p>因为我们执行的命令在 docker 的容器中,如果我们要执行一些 eos 的命令就需要进入 docker 中,我们设置一个别名方便我们调用。</p><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias cleos=&apos;docker-compose -f eos-local-compose.yml exec keosd /opt/eosio/bin/cleos -u http://nodeosd:8888 --wallet-url http://localhost:8900&apos;</span><br></pre></td></tr></table></figure><p>注意：调用cleos时候需要在 <code>eos-local-compose.yml</code> 文件夹下。</p><p>执行 <code>cleos get info</code></p><p>会打印出当前信息，如图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvco4oiv7rj30wg0i2my2.jpg" alt="info]"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看正在运行的容器<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p></p><p>停止某个正在运行的容器<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop name</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 17 2018 17:34:55 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;接下来计划做一个 EO
      
    
    </summary>
    
    
      <category term="EOS" scheme="http://tanfujun.com/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>zeppelinos 初探</title>
    <link href="http://tanfujun.com/2018/09/11/preliminary-study-of-zeppelinos/"/>
    <id>http://tanfujun.com/2018/09/11/preliminary-study-of-zeppelinos/</id>
    <published>2018-09-11T06:56:41.000Z</published>
    <updated>2018-09-12T03:25:45.499Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 17 2018 17:34:55 GMT+0800 (CST) --><p>之前在开发以太坊合约的时候一直会使用openzepplin的库,今天看见推出了ZeeplinOS这个项目,研究了一下。</p><blockquote><p><a href="https://zeppelinos.org/" target="_blank" rel="noopener">https://zeppelinos.org/</a><br>ZeppelinOS 是专为智能合约设计的操作系统，它不仅提供链上可升级的程序编码库，而且还提供保持程序持续升级、修补的奖励机制。</p></blockquote><p>个人理解本质上是对 Truffle 进行了整合,然后把很多代码库做成了库的模式方便开发者使用，在过程中还引入了激励机制让开发者一起维护。</p><p>如果是有 Truffle 使用经验的人的话应该是比较容易上手的。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先安装 <code>zos</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global zos</span><br></pre></td></tr></table></figure><p>然后初始化项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-app &amp;&amp; <span class="built_in">cd</span> my-app</span><br><span class="line">npm init</span><br><span class="line">zos init my-app</span><br></pre></td></tr></table></figure><p>这里会生成 <code>zos.json</code> 这个文件中会记录应用的信息。</p><p>安装 <code>zos-lib</code> zos库:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install zos-lib</span><br></pre></td></tr></table></figure><p>进行合约编写 MyContract.sol 放在 contracts/ 目录下面:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^0.4.21;</span><br><span class="line">import <span class="string">"zos-lib/contracts/migrations/Migratable.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract MyContract is Migratable &#123;</span><br><span class="line">  uint256 public x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> initialize(uint256 _x) isInitializer(<span class="string">"MyContract"</span>, <span class="string">"0"</span>) public &#123;</span><br><span class="line">    x = _x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的合约规则和 solidity 原生的规则略有差别，使用 intialize 作为构造函数，zos 的要求。</p><p>进行合约编译:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zos add MyContract</span><br></pre></td></tr></table></figure><p>接下来启动区块链网络，这样我没有按照官网来启动 <code>ganache-cli</code> 而是打开 <code>Ganache</code> 然后修改 <code>truffle-config.js</code> 中的端口号</p><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">zos push --network <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>推送你的应用到区块链网络。</p><p>我理解push命令是推送一个应用到区块链网络，zeppelin应该是认为应用由多个合约组成，合约是可以升级的。</p><p>创建合约的实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zos create MyContract --init initialize --args 42 --network <span class="built_in">local</span></span><br></pre></td></tr></table></figure><h2 id="升级合约"><a href="#升级合约" class="headerlink" title="升级合约"></a>升级合约</h2><p>如果你发现合约有问题要升级合约,比如官方例子给合约增加了一个函数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"zos-lib/contracts/migrations/Migratable.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract MyContract is Migratable &#123;</span><br><span class="line">  uint256 public x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> initialize(uint256 _x) isInitializer(<span class="string">"MyContract"</span>, <span class="string">"0"</span>) public &#123;</span><br><span class="line">    x = _x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> increment() public &#123;</span><br><span class="line">    x += 1;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把新的代码推送到网络：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zos push --network <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p></p><p>执行更新命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zos update MyContract --network <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p></p><h2 id="使用标准库"><a href="#使用标准库" class="headerlink" title="使用标准库"></a>使用标准库</h2><p>官方提供了标准库方便开发者使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zos link openzeppelin-zos</span><br></pre></td></tr></table></figure><p>使用这些库可以简化智能合约的开发。</p><h2 id="原理推测"><a href="#原理推测" class="headerlink" title="原理推测"></a>原理推测</h2><p>我还没有详细研究 zeepelin 辅助实现合约升级的原理，初步猜想应该是通过代理模式，首先部署一个合约,然后通过这个合约来调用其他合约的方法，变更的时候就是调用地址的转向。估计实际的实现应该考虑了更多场景，更多的方案。</p><p>关于合约升级，推荐大家阅读2篇文章。</p><p><a href="https://segmentfault.com/a/1190000015732881" target="_blank" rel="noopener">智能合约升级模式介绍 — 入门篇</a><br><a href="https://segmentfault.com/a/1190000015732950" target="_blank" rel="noopener">深度剖析智能合约升级——inherited storage</a></p><p>Zeppelin 的具体实现之后再研究。个人觉得能快速帮助开发者实现合约编写是很好的,如果能有 Truffle box 那种直接生成前端框架的命令就更好了,现在这种情况，,对于编写应用的开发者还做不到开箱即用。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 17 2018 17:34:55 GMT+0800 (CST) --&gt;&lt;p&gt;之前在开发以太坊合约的时候一直会使用openzepplin的库,今天看见推出了ZeeplinOS这个项目,研究了一下。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="ETH" scheme="http://tanfujun.com/categories/ETH/"/>
    
    
      <category term="ETH" scheme="http://tanfujun.com/tags/ETH/"/>
    
      <category term="zeppelin" scheme="http://tanfujun.com/tags/zeppelin/"/>
    
  </entry>
  
</feed>
